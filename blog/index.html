<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<link rel="stylesheet" href="main.css" type="text/css" />
<link rel="stylesheet" href="blog.css" type="text/css" />
<link rel="alternate" type="application/rss+xml" title="Subscribe to this page..." href="feed.rss" />
<title>Web notes</title>
</head><body>
<div id="divbodyholder">
<div class="headerholder"><div class="header">
<div id="title">
<h1 class="nomargin"><a class="ablack" href="https://gomes-fdr.github.io/blog/index.html">Web notes</a></h1>
<div id="description">Alguns caracteres perdidos...</div>
</div></div></div>
<div id="divbody"><div class="content">
<h3><a class="ablack" href="oh-my-bash8667.html">
Oh my bash!
</a></h3>
<!-- bashblog_timestamp: #202006010839.52# -->
<div class="subtitle">June 01, 2020 &mdash; 
Fabiano Gomes
</div>
<!-- text begin -->

<p><a href="https://ohmybash.github.io/">Oh my bash</a> é um daqueles projetos que não podem faltar na caixa de ferramentas de qualquer um que use um terminal como base para executar ou mesmo editar código em sistemas baseados em Linux.</p>

<p>Mas do que se trata isso?
Para que serve?</p>

<p>Bom quando abrimos um terminal, normalmente temos algo do tipo:</p>

<pre><code>usuario@host:
</code></pre>

<p>Não deixa de ser uma informação útil, mas podemos tornar isso muito mais interessante. É ai que entra os serviços do oh-my-bash, vamos lá.</p>

<pre><code>sh -c "$(curl -fsSL https://raw.github.com/ohmybash/oh-my-bash/master/tools/install.sh)"
</code></pre>

<p>Isso nos dá um prompt do tipo:</p>

<pre><code>08:22:04 usuario@host ~ →
</code></pre>

<p>Mas não mudou nada! Calma lá cara pálida, essa ferramenta adiciona algumas funcionalidades interessantes ao nosso prompt, por exemplo:</p>

<ul>
<li>Informações sobre um repositório git</li>
<li>Informações sobre o uso de ambientes virtuais(como o <code>virtualenv</code> do python)</li>
</ul>

<p>Um exemplo de prompt:</p>

<pre><code>|venv-3.8.2| host in ~/tmp
○ →
</code></pre>

<p>Outro exemplo estando dentro de um projeto versionado pelo git:</p>

<pre><code>host in ~/.oh-my-bash
± |master ✓| →
</code></pre>

<p>Este prompt está usando o tema <code>tylenol</code>, os temas estão em: <code>$HOME/.oh-my-bash/themes</code> e são escolhidos no arquivo de configuração <code>.bashrc</code> - vale a pena explorar.</p>

<p>Tags: <a href='tag_dev-tools.html'>dev-tools</a>, <a href='tag_bash.html'>bash</a></p>
<!-- text end -->
<h3><a class="ablack" href="conhecendo-deno-ema-node-killerem.html">
Conhecendo deno, <em>a node killer?!</em>
</a></h3>
<!-- bashblog_timestamp: #202005221655.11# -->
<div class="subtitle">May 22, 2020 &mdash; 
Fabiano Gomes
</div>
<!-- text begin -->

<p>Em maio tivemos o lançamento da nova runtime de js, o <a href="https://deno.land/">deno</a>. Vamos brincar um pouco.</p>

<h2>Instalação</h2>

<p>É muito fácil instalar o deno, o site explica de forma bem simplificada como fazer, mas vamos fazer um pouco diferente, utilizando o <a href="https://asdf-vm.com">ASDF</a>:</p>

<pre><code>asdf list all deno      # Para ver todoas as versões disponíveis
asdf install deno 1.0.1 # Instalação da versão mais atual nesta época
asdf global deno 1.0.1  # Ativando o uso da versão instalada
</code></pre>

<p>Pronto!</p>

<h2>Primeiro teste</h2>

<p>Vamos ver se tudo está ok:</p>

<pre><code>deno -V
deno 1.0.1
</code></pre>

<p>Mãos no código:</p>

<pre><code>deno
Deno 1.0.1
exit using ctrl+d or close()
&gt; 
let hello = "olá deno"
console.log(hello)
olá deno
undefined
</code></pre>

<h2>Segundo teste, usando um arquivo</h2>

<pre><code>deno run hello.ts # Sim, typescript é builtin
Compile file:///hello.ts
Olá deno
</code></pre>

<h2>Nota final</h2>

<p>Ainda estou conhecendo mais a respeito do uso de runtimes javascript/typescript, fazem parte da stack que usamos no meu trabalho, acho interessante conhecer as possibildades tanto do chamado padrão de mercado, quanto de opções recém chegadas.</p>

<p>Tags: <a href='tag_javascript.html'>javascript</a>, <a href='tag_typescript.html'>typescript</a>, <a href='tag_deno.html'>deno</a></p>
<!-- text end -->
<h3><a class="ablack" href="setup-de-um-linux-para-desenvolvedor-parte-1.html">
Setup de um Linux para DESENVOLVEDOR
</a></h3>
<!-- bashblog_timestamp: #202005141742.47# -->
<div class="subtitle">May 14, 2020 &mdash; 
Fabiano Gomes
</div>
<!-- text begin -->

<p>O ambiente de trabalho, no caso uma máquina com Linux, reflete diretamente na qualidade da execução de tarefas, para desenvolvedores de softwares é fortemente recomendado um ambiente simples, robusto e estável. Pensando nisso, neste vasto universo de distribuições, duas opções bem ortodoxas se destacam. Debian e Slackware, você estará muito bem servido com qualquer uma delas, neste tutorial vamos explorar o Slackware Linux, por que?! Porque é divertido!</p>

<h2>Instalação</h2>

<p>Vou considerar que temos uma instalação de Slackware Linux nova, aqui temos duas possibilidades no que toca instalações:</p>

<ul>
<li>Sem UEFI: Para máquinas com BIOS de antes de 2008(eu acho), no momento de fazer as partições do HD(usando cfdisk) escolher a opção <em>dos</em>;</li>
<li>Com UEFI: Máquinas com BIOS pós 2008, no momento de fazer as partições do HD(usando cfdisk) escolher a opção <em>gpt</em>;</li>
</ul>

<h2>Esquema de partições</h2>

<p>Aqui vamos primar por um esquema simples também:</p>

<ul>
<li>Sem UEFI: 
<ul>
<li>sda1: para /, ext4, 50GB</li>
<li>sda2: para /home, ext4, o que sobrou de espaço em disco após criar sda3</li>
<li>sda3: para swap - a regra para o tamanho do swap é 2XRAM, sendo no máximo 8GB de tamanho(na prática 4GB de swap resolve tua vida).</li>
</ul></li>
<li>Com UEFI: Um pouco mais complexo, este <a href="https://youtu.be/fd0FvvsGaUM">vídeo</a> é uma excelente referência.</li>
</ul>

<p>Embora a instalação seja importante, considero que a pós-instalação é o que realmente faz a diferença, vamos lá!</p>

<h2>Pós-instalação</h2>

<p>A partir deste ponto é onde quero levantar os diferenciais, na minha modesta opinião.</p>

<p>Ao final de uma instalação de Slackware, temos apenas um super usuário e nada mais, vamos começar a preparar nosso ambiente para não precisarmos nos preocupar com eventuais quebras por instalações/atualizações desnecessárias.</p>

<ol>
<li>Conectar na internet: Temos duas opções, a mais tradicional, usando um cabo de rede. Ou caso estejamos usando um notebook, devemos instalar o pacote que está no dvd de instalação do Slackware, na seção extra/wicd chamado wicd-xxx.txz, com ele instalado podemos utilizar o comando <code>wicd-curses</code> no terminal e fazer nossa conexão com a rede que desejamos. Aqui é importante lembrar que o serviço NetworkManager deve estar ativo(<code>chmod +x /etc/rc.d/rc.networkmanager</code>)</li>
<li><p>Após logar como root, vamos escolher um mirror no arquivo /etc/slackpkg/mirrors: Escolha um mirror do Brasil, não vou utilizar o slackware current(não é o objetivo aqui) execute:</p>

<pre><code>slackpkg upgrade
slackpkg upgrade-all
</code></pre></li>
</ol>

<p>Após esse procedimento seu slackware estará atualizadissimo!</p>

<h2>Instalando novos software</h2>

<p>O Slackware tem a má fama de não possuir nenhum gerenciador de pacotes, o que já verificamos não ser verdade no item <em>pós-instalação</em>. Agora vamos adicionar novas ferramentas a nossa caixa de desenvolvimento, o <a href="https://sbopkg.org/">sbopkg</a> é um facilitador para acessarmos o repositório de receitas do <a href="https://slackbuilds.org/">slackbuilds</a>. </p>

<ol>
<li>Baixar o pacote sbopkg-xxx.tgz e instala-lo com o <code>installpkg sbopkg-xxx.tgz</code>;</li>
<li>A partir daqui sempre vamos executar o <code>sbopkg</code> para fazer a instalação de novos pacotes no nosso Slackware.</li>
</ol>

<h2>Próximos passos</h2>

<p>No próximo tutorial vamos configurar um WM(Windown Manager) e adicionar mais ferramentas na nossa caixa de desenvolvimento.</p>

<p>Tags: <a href='tag_wiki.html'>wiki</a>, <a href='tag_linux.html'>linux</a>, <a href='tag_slackware.html'>slackware</a></p>


<!-- text end -->
<h3><a class="ablack" href="minhas-notas-sobre-uso-do-git.html">
Minhas notas sobre uso do git
</a></h3>
<!-- bashblog_timestamp: #202005110818.38# -->
<div class="subtitle">May 11, 2020 &mdash; 
Fabiano Gomes
</div>
<!-- text begin -->

<p>Para <em>trazer</em> os submodulos de um projeto:</p>

<pre><code>git submodule init
</code></pre>

<p>Para <em>atualizar</em> os submodulos:</p>

<pre><code>git submodule update
</code></pre>

<p>Para <em>chavear</em> para um branch especifico dos submodulos:</p>

<pre><code>git submodule foreach 'git checkout develop'
</code></pre>

<p>Para <em>traze</em>' as atualizações de todos os sbmodulos:</p>

<pre><code>git submodule foreach 'git pull'
</code></pre>

<p>Para <em>guardar</em> as alterações em uma pilha <em>anonima</em>:</p>

<pre><code>git stash
</code></pre>

<p>Para aplicar as alterações dessa pilha no branch corrente:</p>

<pre><code>git stash apply
</code></pre>

<p>Para guardar inclusive untracked files:</p>

<pre><code>git stash -u
</code></pre>

<p>Para listar a pilha de <em>stashes</em></p>

<pre><code>git stash list
</code></pre>

<p>Para criar um novo branch a partir de um stash:</p>

<pre><code>git stash branch novo-branch
</code></pre>

<p>Para acessar um stash especifico, acessa através de stash@{n} - por exemplo:</p>

<pre><code>git stash apply stash@{2} # aplica o stash 2 ao branch corrent
git stash drop stash@{2} # Apaga o stash 2 da pilha
</code></pre>

<p>Apagar a pilha de stash:</p>

<pre><code>git stash clear
</code></pre>

<h2>Comparar modificações</h2>

<p>Configurar ferramenta de diff:</p>

<pre><code>git config --global diff.tool meld
</code></pre>

<p>Para comparar dois branches usando a ferramenta gráfica <em>Meld</em>:</p>

<pre><code>git difftool -d ticket-4581..develop
</code></pre>

<p>A lógica é a mesma para fazer um diff entre commits, basta substituir o nome do branch pelo hash do commit(os primeiros 6 digitos são o suficiente).</p>

<h2>Juntar commits</h2>

<p>Para <em>juntar</em> varios commits em um só:</p>

<pre><code>git rebase -i HEAD~&lt;n&gt; # Onde n é a quantidade de commits que desejamos juntar.
</code></pre>

<p>Neste comando iterativo podemos juntar, squash ou remover algum commit que não queremos - para isso basta remover a linha pick que contém o commit(leia as instruções do modo iterativo).</p>

<p>Tags: <a href='tag_wiki.html'>wiki</a></p>



<!-- text end -->
<h3><a class="ablack" href="dicas-para-uso-do-docker.html">
Dicas para uso do docker
</a></h3>
<!-- bashblog_timestamp: #202005110757.24# -->
<div class="subtitle">May 11, 2020 &mdash; 
Fabiano Gomes
</div>
<!-- text begin -->

<p>Referencias utilizadas:
<a href="https://youtu.be/aHbE3pTyG-Q">link</a></p>

<p>Instalar um container - docker hub</p>

<pre><code>docker pull postgres:alpine
</code></pre>

<p>Listar containers instalados</p>

<pre><code>docker images -a
</code></pre>

<p>Remover um container</p>

<pre><code>docker rmi &lt;nome-do-container&gt;
</code></pre>

<p>Iniciar um container</p>

<pre><code>docker run --name postgres-0 -e POSTGRES_PASSWORD=1234 -d -p 5432:5432 postgres:alpine
</code></pre>

<p>Processo docker rodando</p>

<pre><code>docker ps
</code></pre>

<p>Para subir uma imagem existente</p>

<pre><code>docker start postgres-0 # &lt;container-name&gt;
</code></pre>

<p>Parar o container</p>

<pre><code> docker stop postgres-0 # &lt;container-name&gt;
</code></pre>

<p>Para entrar no container</p>

<pre><code>docker exec -it postgres-0 bash
</code></pre>

<p>Para acessar o banco de dados postgre dentro do container(console postgres)</p>

<pre><code>psql -U postgres
</code></pre>

<p>Para fazer o dump do banco do container</p>

<pre><code>docker exec -t postgres-0 pg_dumpall -a &gt; dump_`date +%d-%m-%Y"_"%H_%M_%S`.sql
docker exec -t postgres-0 pg_dump -a &gt; dump_`date +%d-%m-%Y"_"%H_%M_%S`.sql
</code></pre>

<p>Para restaurar o banco apartir de um dump file</p>

<pre><code>cat your_dump.sql | docker exec -i your-db-container psql -U postgres
</code></pre>

<p>VERIFICA SE A PORTA ESTÁ EM USO</p>

<pre><code>netstat -an | grep 5432
</code></pre>

<p>STOP POSTGRE SERVICE</p>

<pre><code>sudo service postgresql stop
</code></pre>

<p>Copiar arquivo para container:</p>

<pre><code>docker cp &lt;arquivo&gt; &lt;container_id&gt;:/
</code></pre>

<p>Acessar o postgres do container:</p>

<pre><code>psql -h localhost -p 5432 -U postgres
</code></pre>

<p>Para criar um novo banco no postgre via CL:</p>

<pre><code>createdb -U &lt;role&gt; &lt;nome-banco&gt;
</code></pre>

<h2>Outra maneira de fazer o backup</h2>

<pre><code>docker exec -u &lt;your_postgres_user&gt; &lt;postgres_container_name&gt; pg_dump -Fc &lt;database_name_here&gt; &gt; db.dump
</code></pre>

<h2>Cuidado!</h2>

<pre><code>docker exec -u &lt;your_postgres_user&gt; &lt;postgres_container_name&gt; psql -c 'DROP DATABASE &lt;your_db_name&gt;'

docker exec -i -u &lt;your_postgres_user&gt; &lt;postgres_container_name&gt; pg_restore -C -d postgres &lt; db.dump
</code></pre>

<p>Exemplo:</p>

<p>Custom format (c)</p>

<pre><code>docker exec -u labwide postgres-0 pg_dump -Fc gestam-dados &gt; gestam-dados.dump
</code></pre>

<p>SQL format(p)</p>

<pre><code>docker exec -u postgres postgres-0 pg_dump -Fp gestam-dados &gt; gestam-dados.dump
</code></pre>

<h2>Backup acessando o container</h2>

<p><strong>copy dump into container</strong></p>

<pre><code>docker cp local/path/to/db.dump CONTAINER_ID:/db.dump
</code></pre>

<p><strong>shell into container</strong></p>

<pre><code>docker exec -it CONTAINER_ID bash
</code></pre>

<p><strong>restore it from within</strong></p>

<pre><code>pg_restore -U postgres -d DB_NAME --no-owner -1 /db.dump
</code></pre>

<p>Tags: <a href='tag_wiki.html'>wiki</a></p>



<!-- text end -->
<h3><a class="ablack" href="ferramentas-para-dev-asdf11978.html">
Ferramentas Para Dev, ASDF
</a></h3>
<!-- bashblog_timestamp: #202005110757.24# -->
<div class="subtitle">May 11, 2020 &mdash; 
Fabiano Gomes
</div>
<!-- text begin -->

<p>Quando começamos a desenvolver software, precisamos montar nossa "caixa de ferramentas" - uma coleção de programas que nos ajudam a ser mais produtivo na criação de software. Se trabalhamos com linguagens interpretadas como javascript, python ou lua - para citar algumas com as quais eu trabalho, é muito comum precisarmos utilizar diferentes versões de interpretadores. É muito complicado e chato fazer isso manualmente, existem diversas ferramentas que resolvem esse tipo de problema dentro do seu escopo, ruby tem o seu gerenciador de ambientes virtuais, python também e por ai vai.
Felizmente alguém pensou em fazer um gerenciador "genérico" para ajudar um grande número de desenvolvedores das mais diversas linguagens, esse projeto chama-se <a href="https://asdf-vm.com">ASDF</a> e resolve de uma forma muito elegante o problema de convivência de diferentes interpretadores num mesmo computador, vamos ver como fazer a instalação e configuração dele para alguns interpretadores.</p>

<h2>Instalação</h2>

<p>Tudo que estou postando aqui foi retirado do site oficial do <a href="https://asdf-vm.com">ASDF</a> sem dúvida a melhor fonte para funcionalidades mais específicas.</p>

<pre><code>git clone https://github.com/asdf-vm/asdf.git ~/.asdf --branch v0.7.3
</code></pre>

<h2>Tonar visível para o seu shell</h2>

<pre><code>echo -e '\n. $HOME/.asdf/asdf.sh' &gt;&gt; ~/.bashrc
echo -e '\n. $HOME/.asdf/completions/asdf.bash' &gt;&gt; ~/.bashrc
</code></pre>

<h2>Como o ASDF funciona?</h2>

<p>Ele não armazena cada versão de interpretador no site do projeto, ao invés disso através de receitas é feita a instalação das diferentes versões dos interpretadores que você precisa - na linguagem do ASDF, estas receitas são chamadas de plugins. Então a primeira coisa a ser feita após a instalação do ASDF é a escolha de quais linguagens vamos trabalhar, neste exemplo vou mostrar como fazer a instalação de diferntes versões de Lua.</p>

<h2>Listando os plugins disponíveis</h2>

<p>Para saber quais as versões são possíveis de instalar, basta:</p>

<pre><code>asdf list-all lua
</code></pre>

<p>Uma saída semelhante a essa será exibida:</p>

<pre><code>asdf list-all lua
5.1
5.2.0
5.2.1
5.2.2
5.2.3
5.2.4
5.3.0
5.3.1
5.3.2
5.3.3
5.3.4
5.3.5
</code></pre>

<h2>Instalando o plugin</h2>

<pre><code>asdf plugin-add lua
</code></pre>

<h2>Instalando uma versão</h2>

<pre><code>asdf install lua 5.2.4
</code></pre>

<h2>Tornando a versão instalada ativa</h2>

<pre><code>asdf global lua 5.2.4
</code></pre>

<p>Aqui cabe um observação importante, como foi dito anteriormente o ASDF não mantém uma cópia dos interpretadores compilados em seu site, ele é apenas um repositório de receitas. Logo essa receita vai baixar os fontes dos respectivos projetos e compila-los - para isso é importante que as dependências necessárias para compilar cada interpretador estejam presentes no seu computador. Em cada repositório de plugin temos uma lista do que é necessário e de como fazer a instalação destas dependências.</p>

<h2>Um exemplo de instalações</h2>

<pre><code>asdf list
lua
  5.2.4
  5.3.5
python
  3.7.4
asdf current
   lua            5.3.5    (set by /home/fabiano/.tool-versions)
   python         3.7.4    (set by /home/fabiano/.tool-versions)
</code></pre>

<p>Para outros interpretadores basta repetir o processo, facinho.
Finalizamos por aqui esse tutorial, em caso de dúvidas, deixe seu comentário.</p>

<p>Tags: <a href='tag_wiki.html'>wiki</a></p>



<!-- text end -->
<div id="all_posts"><a href="all_posts.html">View more posts</a> &mdash; <a href="all_tags.html">All tags</a> &mdash; <a href="feed.rss">Subscribe</a></div>
</div>
<div id="footer">CC by-nc-nd <a href="">Fabiano Gomes</a> &mdash; <a href="mailto:gomes&#46;fdr&#64;tuta&#46;io">gomes&#46;fdr&#64;tuta&#46;io</a><br/>
Generated with <a href="https://github.com/cfenollosa/bashblog">bashblog</a>, a single bash script to easily create blogs like this one</div>
</div></div>
</body></html>
