<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<link rel="stylesheet" href="main.css" type="text/css" />
<link rel="stylesheet" href="blog.css" type="text/css" />
<link rel="alternate" type="application/rss+xml" title="Subscribe to this page..." href="https://gomes-fdr.github.io/blog/feed.rss" />
<title>Web notes</title>
</head><body>
<div id="divbodyholder">
<div class="headerholder"><div class="header">
<div id="title">
<h1 class="nomargin"><a class="ablack" href="https://gomes-fdr.github.io/blog/index.html">Web notes</a></h1>
<div id="description">Alguns caracteres perdidos...</div>
</div></div></div>
<div id="divbody"><div class="content">
<h3><a class="ablack" href="ponteiros-em-golang.html">
Ponteiros em golang
</a></h3>
<!-- bashblog_timestamp: #202006201330.49# -->
<div class="subtitle">June 20, 2020 &mdash; 
Fabiano Gomes
</div>
<!-- text begin -->

<p>Em tradução livre, ponteiros são objetos que armazenam endereços de memória <a href="https://en.wikipedia.org/wiki/Pointer_(computer_programming">wikipedia</a>. Um dos temas que podemos tratar quando passamos a utilizar ponteiros, é a maneira como <em>passamos</em> informações de uma função para outra.</p>

<p>Por padrão, quando criamos uma função e definimos algum parâmetro, utilizamos a chamada <em>passagem por referência</em> onde este parâmetro, solicita para o computador que ele reserve um pouco de memória para armazenar o conteúdo de cada parâmetro declarado(sim parâmetros são como as variáveis dos nossos programas).</p>

<pre><code>func dobro(a int) int {
    return a*2
}
</code></pre>

<p>No exemplo acima, uma variável do tipo <code>int</code> foi criada, para receber o valor da nossa função <code>dobro</code>, dentro do nosso programa principal, poderíamos utilizar essa função da seguinte maneira:</p>

<pre><code>func main() {
    x := 10

    fmt.Println("O valor de x  é: ", x)
    fmt.Println("Seu dobro é: ", dobro(x))
}
</code></pre>

<p>A grosso modo, no exemplo acima, criamos duas variáveis de tamanho de um <code>int</code>, como poderíamos fazer a mesma operação sem alocarmos mais uma variável?</p>

<h2>Passagem por referência</h2>

<p>Vamos fazer alguns ajustes na função dobro:</p>

<pre><code>func dobro(a *int) int {
    return *a * 2
}
</code></pre>

<p>Agora a função dobro espera receber um ponteiro, ou se preferir uma referência para uma variável do tipo <code>int</code>, na função principal, a utilização da nossa função que trabalha com referências fica assim:</p>

<pre><code>func main() {
    x := 10

    fmt.Println("O valor de x  é: ", x)
    fmt.Println("Seu dobro é: ", dobro(&amp;x))
}
</code></pre>

<p>Com essa alteração, passamos a reservar apenas uma variável do tipo <code>int</code>, uma vez que nossa função apenas <em>apontou</em> para o valor da variável x e retornou seu valor multiplicado por 2.</p>

<p>Assim como em C e C++ dá pra fazer muitas coisas legais e perigosas com ponteiros, essa foi uma pequena nota para meu eu do futuro pensar a respeito.</p>

<p><em>Importante lembrar que o uso irresponsável de ponteiros pode trazer efeitos indesejados(eu ouvi garbage colector?!)</em></p>

<p>Referências: Série de vídeos do <a href="https://youtu.be/JepHr8egvBI">Claudson Oliveira</a></p>

<p>Tags: <a href='tag_golang.html'>golang</a>, <a href='tag_wiki.html'>wiki</a></p>
<!-- text end -->
<h3><a class="ablack" href="golang-sobre-strings.html">
Golang, sobre strings
</a></h3>
<!-- bashblog_timestamp: #202006142108.25# -->
<div class="subtitle">June 14, 2020 &mdash; 
Fabiano Gomes
</div>
<!-- text begin -->

<p>Estas são algumas anotações que estou fazendo durante o excelente vídeo curso da <a href="https://www.youtube.com/playlist?list=PLCKpcjBB_VlBsxJ9IseNxFllf-UFEXOdg">Ellen Köbes</a> - o conteúdo e alguns trechos de código são de lá.</p>

<h2>O tipo string</h2>

<p>Uma das coisas que achei muito legal em Go, tudo é utf-8! O código fonte e o tipo string é em utf-8. Bom só quem já usou IDEs como o qtcreator ou o eclipse sabe os tipos de problemas inesperados que podemos ter pelo simples fato de o encode do código fonte poder estar em diversos formatos(lá se vão todas as mensagens para o usuário final com caracteres alienígenas).</p>

<h2>Nota histórica</h2>

<p>O mindset para lidar com texto em C, é o seguinte:</p>

<pre><code>"Strings são uma cadeia de char finalizadas com `0`."
</code></pre>

<p>Para lidar com ASCII, tudo bem, mas o mundo é muito grande e trabalhar com todos os símbolos que usamos para nos comunicar, usando apenas a tabela ASCII era um ginástica danada.</p>

<p>Seguindo:</p>

<pre><code>"Um char, em C, são 8 bits."
</code></pre>

<p>Observando estas notas históricas, vejo como foi acertada a escolha de utf-8 para lidar com string em Go.</p>

<h2>Como é em Golang</h2>

<p>Go criou um alias para <code>unit32</code> chamado <code>rune</code>, cada <code>rune</code> representa um caractere de uma string em Go. Isso impacta diretamente em operações de slice(fatiamento).</p>

<pre><code>package main

import (
    "fmt"
)

func main() {
    a := "e"
    b := "é"
    c := "香"
    fmt.Printf("%v, %v, %v\n", a, b, c)

    d := []byte(a)
    e := []byte(b)
    f := []byte(c)

    fmt.Printf("%v, %v, %v", d, e, f)
}

e, é, 香
[101], [195 169], [233 166 153]
</code></pre>

<p>Observe:</p>

<pre><code>// caractere | decimal | hexa | binário  | no. byte(s)
           e |     101 |   65 |  1100101 |           1
           é |   50089 |   C3 | 11000011 |
             |         |   A9 | 10101001 |           2
          香 | 15312537|   E9 | 11101001 |
                           A6 | 10100110 |
                           99 | 10011001 |           3
</code></pre>

<p>O primeiro caractere <code>e</code> está na tabela ASCII, utf-8 é um superset desta tabela, logo pode representar seus valores com total compatibilidade. Como tal, usa um byte para representa-lo.</p>

<p>O segundo caractere não pode ser representado usando ASCII, logo cai nos casos em que utf-8 passa a nos ajudar de fato, para representar esse caractere, são necesários 2 bytes.</p>

<p>O terceiro caractere também não pode ser representado usando ASCII e está em um range superior da tabela utf-8 e necessita de 3 bytes para representa-lo.</p>

<p>Em resumo, a tabela ASCII pode representar 2<sup>8</sup> valores diferentes(256), já a tabela de utf-8 pode representar 2<sup>32</sup> valores diferentes(4294967296) - sendo que ASCII está contido nesta tabela, acho que até o alfabeto Klingon está lá.</p>

<p>Este exemplo simples mostra muito bem como fica fácil de lidar com strings em Golang, gostaria de deixar o link para uma excelente explicação complementar de como funciona a lógica por trás da codificação utf-8, ele também é um material criado pela <a href="https://medium.com/deffectivego/wtf-utf-8-85bc66a6279">Ellen Köbes</a>.</p>

<p>Recomendo fortemente.</p>

<p>Tags: <a href='tag_golang.html'>golang</a>, <a href='tag_wiki.html'>wiki</a></p>


<!-- text end -->
<h3><a class="ablack" href="aprendendo-golang.html">
Aprendendo golang
</a></h3>
<!-- bashblog_timestamp: #202006111909.59# -->
<div class="subtitle">June 11, 2020 &mdash; 
Fabiano Gomes
</div>
<!-- text begin -->

<p>Algumas regras que me ajudam a dar um boost no entendimento de novas tecnolgias:</p>

<ul>
<li>Ler a documentação do projeto <a href="https://golang.org/">golang</a></li>
<li>Aprender usando testes <a href="https://en.wikipedia.org/wiki/Test-driven_development">TDD</a></li>
<li>Aprender com exemplos</li>
<li><a href="https://www.youtube.com/playlist?list=PLCKpcjBB_VlBsxJ9IseNxFllf-UFEXOdg">Vídeos aulas</a> de qualidade, dica do brother <a href="https://gushmsilva.keybase.pub/">Gusta</a></li>
</ul>


<p>Tendo isso como diretiva, vamos começar essa jornada, vamos adionar isso no  arquivo <code>bash_profile</code></p>

<pre><code>export GOPATH=$HOME/go
export PATH=$PATH:$GOPATH/bin
</code></pre>

<p>Depois vamos criar os seguintes diretórios:</p>

<pre><code>mkdir -p $GOPATH/src $GOPATH/pkg $GOPATH/bin
</code></pre>

<p><a href="https://quii.gitbook.io/learn-go-with-tests/">Referências</a></p>

<h2>Coisas que gostei até aqui</h2>

<ul>
<li>Syntax fácil</li>
<li>Instalação de pacotes/depedências</li>
<li>Farta documentação, <a href="https://godoc.org/">Godoc</a></li>
<li>Geração de binários</li>
<li>Formatação de código é builtin</li>
<li>Suite de testes é builtin</li>
<li>Lembra muito C, na sintaxe</li>
<li>Lembra muito C, com structs</li>
<li>Não usa <code>;</code> para finalizar instruções</li>
<li>[Short|gopher] operator é muito massa</li>
<li>Controle de imports é builtin</li>
<li>Controle de uso de variáveis é builtin</li>
<li>Fazer build é uma barbada(alguém falou makefile?!)</li>
<li>Code-OSS é um editor honesto</li>
</ul>


<h2>Coisas que vou investigar melhor</h2>

<ul>
<li>Lidar com módulos</li>
<li>Compilação cruzada</li>
<li>Criação de APIs</li>
<li>Criação de GUIs</li>
<li>Integração com frontend web</li>
</ul>


<p>  Tags: golang, wiki</p>



<!-- text end -->
<h3><a class="ablack" href="notas-sobre-c-e-o-framework-qt.html">
Notas sobre C++ e o Framework Qt
</a></h3>
<!-- bashblog_timestamp: #202006050852.07# -->
<div class="subtitle">June 05, 2020 &mdash; 
Fabiano Gomes
</div>
<!-- text begin -->

<h2>Uso de notação húngara</h2>

<p>Bastante usada por programadores vindos do Pascal ou Fortram, tenta, através de notação inferir de que tipo ou contexto está tratando.</p>

<pre><code>/*
    g_nWheels : member of a global namespace, integer
    m_nWheels : member of a structure/class, integer
    m_wheels, _wheels : member of a structure/class
    s_wheels : static member of a class
    c_wheels : static member of a function
*/
</code></pre>

<h2>Sobre passagem por referência e por valor</h2>

<p>Algumas referências para entender como funciona o uso de referências ou valores.</p>

<pre><code>// C++ program to demonstrate differences between pointer and reference. 
#include &lt;iostream&gt; 
using namespace std; 

struct demo { 
    int a;
}; 

int main() { 
​ int x = 5; 
​ int y = 6; 
​ demo d; 
​ int *p; 
​ p = &amp;x; 
​ p = &amp;y;                 // 1. Pointer reintialization allowed 
​ int &amp;r = x; 
​ // &amp;r = y;              // 1. Compile Error 
​ r = y;                  // 1. x value becomes 6 
​ p = NULL; 
​ // &amp;r = NULL;               // 2. Compile Error 
​ p++;                    // 3. Points to next memory location 
​ r++;                    // 3. x values becomes 7 

​ cout &lt;&lt; &amp;p &lt;&lt; " " &lt;&lt; &amp;x &lt;&lt; endl;    // 4. Different address 
​ cout &lt;&lt; &amp;r &lt;&lt; " " &lt;&lt; &amp;x &lt;&lt; endl;    // 4. Same address 

​ demo *q = &amp;d; 
​ demo &amp;qq = d; 
​ q-&gt;a = 8; 

​ // q.a = 8;              // 5. Compile Error 
​ qq.a = 8; 
​ // qq-&gt;a = 8;                // 5. Compile Error 

​ cout &lt;&lt; p &lt;&lt; endl;           // 6. Prints the address 
​ cout &lt;&lt; r &lt;&lt; endl;           // 6. Print the value of x
​ return 0; 
}
</code></pre>

<p><a href="https://www.geeksforgeeks.org/passing-by-pointer-vs-passing-by-reference-in-c/">Referência</a></p>

<h2>Sobre o uso de const values</h2>

<p>Outra figurinha carimbada, o uso de <code>const</code> - aqui algumas aplicações de uso.</p>

<pre><code>#include &lt;iostream&gt;

// x is a const reference to the argument passed in, not a copy
void printIt(const int &amp;x) {
​    std::cout &lt;&lt; x;
}

int main() {
​    int a = 1;
​    printIt(a);  // non-const l-value

​    const int b = 2;
​    printIt(b);  // const l-value
​    printIt(3);  // literal r-value
​    printIt(2+b);    // expression r-value

​    return 0;
}
</code></pre>

<p><a href="https://www.learncpp.com/cpp-tutorial/6-11a-references-and-const/">Referência</a></p>

<p><strong>Rule:</strong>  Pass non-pointer, non-fundamental data type variables (such as structs) by (const) reference.</p>

<h2>Sobre auto_ptr</h2>

<p>Essa feature permite o uso de tipo por inferição, ou seja, o tipo da variável é definido do lado direito da igualdade(sinal de atribuição).</p>

<pre><code>// C++ program to demonstrate working of auto and type inference 
#include &lt;bits/stdc++.h&gt; 

using namespace std; 

int main() { 
​ auto x = 4; 
​ auto y = 3.37; 
​ auto ptr = &amp;x; 

​ cout &lt;&lt; typeid(x).name() &lt;&lt; endl 
​      &lt;&lt; typeid(y).name() &lt;&lt; endl 
​      &lt;&lt; typeid(ptr).name() &lt;&lt; endl; 

​ return 0; 
}
</code></pre>

<p><a href="https://www.geeksforgeeks.org/type-inference-in-c-auto-and-decltype/">Referência</a></p>

<h2>Uso de iteradores</h2>

<p>Um recurso muito bacana da linguagem, permite subir o nível da conversa quando se fala de <em>navegar</em> em coleções.</p>

<pre><code>#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
​    std::vector&lt;int&gt; v = {0, 1, 2, 3, 4, 5};

​    for (const int&amp; i : v) // access by const reference
​        std::cout &lt;&lt; i &lt;&lt; ' ';
​    std::cout &lt;&lt; '\n';

​    for (auto i : v) // access by value, the type of i is int
​        std::cout &lt;&lt; i &lt;&lt; ' ';
​    std::cout &lt;&lt; '\n';

​    for (auto&amp;&amp; i : v) // access by forwarding reference, the type of i is int&amp;
​        std::cout &lt;&lt; i &lt;&lt; ' ';
​    std::cout &lt;&lt; '\n';

​    const auto&amp; cv = v;
​    for (auto&amp;&amp; i : cv) // access by f-d reference, the type of i is const int&amp;
​        std::cout &lt;&lt; i &lt;&lt; ' ';
​    std::cout &lt;&lt; '\n';

​    for (int n : {0, 1, 2, 3, 4, 5}) // the initializer may be a braced-init-list
​        std::cout &lt;&lt; n &lt;&lt; ' ';
​    std::cout &lt;&lt; '\n';

​    int a[] = {0, 1, 2, 3, 4, 5};
​    for (int n : a) // the initializer may be an array
​        std::cout &lt;&lt; n &lt;&lt; ' ';
​    std::cout &lt;&lt; '\n';

​    for (int n : a)
​        std::cout &lt;&lt; 1 &lt;&lt; ' '; // the loop variable need not be used
​    std::cout &lt;&lt; '\n';
}
</code></pre>

<p><a href="https://en.cppreference.com/w/cpp/language/range-for">Referência</a></p>

<h2>Sobre lambda functions</h2>

<p>Ou funções anônimas, mais um recurso interessante da linguagem</p>

<pre><code>// C++ program to demonstrate lambda expression in C++ 
#include &lt;bits/stdc++.h&gt; 

using namespace std; 

int main() { 
​ vector&lt;int&gt; v1 = {3, 1, 7, 9}; 
​ vector&lt;int&gt; v2 = {10, 2, 7, 16, 9}; 

​ // access v1 and v2 by reference 
​ auto pushinto = [&amp;] (int m) {
​     v1.push_back(m); 
​     v2.push_back(m); 
​ }; 

​ // it pushes 20 in both v1 and v2 
​ pushinto(20); 

​ // access v1 by copy 
​ [v1]() { 
​     for (auto p = v1.begin(); p != v1.end(); p++) { 
​         cout &lt;&lt; *p &lt;&lt; " ";
​     } 
​ }; 

​ int N = 5; 
​ // below snippet find first number greater than N 
​ // [N] denotes, can access only N by value 
​ vector&lt;int&gt;:: iterator p = find_if(v1.begin(), v1.end(), [N](int i) { 
​     return i &gt; N;
​ }); 

​ cout &lt;&lt; "First number greater than 5 is : " &lt;&lt; *p &lt;&lt; endl; 

​ // function to count numbers greater than or equal to N 
​ // [=] denotes, can access all variable 
​ int count_N = count_if(v1.begin(), v1.end(), [=](int a) {
​     return (a &gt;= N);
​ }); 

​ cout &lt;&lt; "The number of elements greater than or equal to 5 is : "
​      &lt;&lt; count_N &lt;&lt; endl; 
}
</code></pre>

<p><a href="https://www.geeksforgeeks.org/lambda-expression-in-c/">Referência 1</a>
<a href="https://docs.microsoft.com/pt-br/cpp/cpp/lambda-expressions-in-cpp?view=vs-2019">Referência 2</a></p>

<h2>Sobre uso de excessões</h2>

<pre><code>#include &lt;iostream&gt;

using namespace std;

double division(int a, int b) {
   if( b == 0 ) {
​      throw "Division by zero condition!";
   }

   return (a/b);
}

int main () {
   int x = 50;
   int y = 0;
   double z = 0;

   try {
​      z = division(x, y);
​      cout &lt;&lt; z &lt;&lt; endl;

   } catch (const char* msg) {
​     cerr &lt;&lt; msg &lt;&lt; endl;
   }

   return 0;
}
</code></pre>

<p><a href="https://www.tutorialspoint.com/cplusplus/cpp_exceptions_handling.htm">Referência</a></p>

<h2>Criando excessões</h2>

<pre><code>#include &lt;iostream&gt;
#include &lt;exception&gt;

using namespace std;

struct MyException : public exception {
   const char * what () const throw () {
​      return "C++ Exception";
   }
};

int main() {
   try {
​      throw MyException();
   } catch(MyException&amp; e) {
​      std::cout &lt;&lt; "MyException caught" &lt;&lt; std::endl;
​      std::cout &lt;&lt; e.what() &lt;&lt; std::endl;
   } catch(std::exception&amp; e) {
​      //Other errors
   }
}
</code></pre>

<h2>Referência da linguagem</h2>

<ul>
<li><a href="https://www.geeksforgeeks.org/c-plus-plus/">Geeks for geeks</a></li>
<li><a href="https://en.cppreference.com/w/cpp/language">CPP Reference</a></li>
<li><a href="https://github.com/rougier/cpp-crash-course">CPP crash course</a></li>
<li><a href="https://en.wikipedia.org/wiki/Hungarian_notation">Notação Hungara</a></li>
<li><a href="https://doc.qt.io/">Documentação oficial</a></li>
<li><a href="https://www.cleanqt.io/home">Clean Qt</a></li>
</ul>

<p>Tags: <a href='tag_C++.html'>C++</a>, <a href='tag_tips.html'>tips</a></p>




<!-- text end -->
<h3><a class="ablack" href="oh-my-bash8667.html">
Oh my bash!
</a></h3>
<!-- bashblog_timestamp: #202006010839.52# -->
<div class="subtitle">June 01, 2020 &mdash; 
Fabiano Gomes
</div>
<!-- text begin -->

<p><a href="https://ohmybash.github.io/">Oh my bash</a> é um daqueles projetos que não podem faltar na caixa de ferramentas de qualquer um que use um terminal como base para executar ou mesmo editar código em sistemas baseados em Linux.</p>

<p>Mas do que se trata isso?
Para que serve?</p>

<p>Bom quando abrimos um terminal, normalmente temos algo do tipo:</p>

<pre><code>usuario@host:
</code></pre>

<p>Não deixa de ser uma informação útil, mas podemos tornar isso muito mais interessante. É ai que entra os serviços do oh-my-bash, vamos lá.</p>

<pre><code>sh -c "$(curl -fsSL https://raw.github.com/ohmybash/oh-my-bash/master/tools/install.sh)"
</code></pre>

<p>Isso nos dá um prompt do tipo:</p>

<pre><code>08:22:04 usuario@host ~ →
</code></pre>

<p>Mas não mudou nada! Calma lá cara pálida, essa ferramenta adiciona algumas funcionalidades interessantes ao nosso prompt, por exemplo:</p>

<ul>
<li>Informações sobre um repositório git</li>
<li>Informações sobre o uso de ambientes virtuais(como o <code>virtualenv</code> do python)</li>
</ul>

<p>Um exemplo de prompt:</p>

<pre><code>|venv-3.8.2| host in ~/tmp
○ →
</code></pre>

<p>Outro exemplo estando dentro de um projeto versionado pelo git:</p>

<pre><code>host in ~/.oh-my-bash
± |master ✓| →
</code></pre>

<p>Este prompt está usando o tema <code>tylenol</code>, os temas estão em: <code>$HOME/.oh-my-bash/themes</code> e são escolhidos no arquivo de configuração <code>.bashrc</code> - vale a pena explorar.</p>

<p>Tags: <a href='tag_dev-tools.html'>dev-tools</a>, <a href='tag_bash.html'>bash</a></p>





<!-- text end -->
<h3><a class="ablack" href="conhecendo-deno-ema-node-killerem.html">
Conhecendo deno, <em>a node killer?!</em>
</a></h3>
<!-- bashblog_timestamp: #202005221655.11# -->
<div class="subtitle">May 22, 2020 &mdash; 
Fabiano Gomes
</div>
<!-- text begin -->

<p>Em maio tivemos o lançamento da nova runtime de js, o <a href="https://deno.land/">deno</a>. Vamos brincar um pouco.</p>

<h2>Instalação</h2>

<p>É muito fácil instalar o deno, o site explica de forma bem simplificada como fazer, mas vamos fazer um pouco diferente, utilizando o <a href="https://asdf-vm.com">ASDF</a>:</p>

<pre><code>asdf list all deno      # Para ver todoas as versões disponíveis
asdf install deno 1.0.1 # Instalação da versão mais atual nesta época
asdf global deno 1.0.1  # Ativando o uso da versão instalada
</code></pre>

<p>Pronto!</p>

<h2>Primeiro teste</h2>

<p>Vamos ver se tudo está ok:</p>

<pre><code>deno -V
deno 1.0.1
</code></pre>

<p>Mãos no código:</p>

<pre><code>deno
Deno 1.0.1
exit using ctrl+d or close()
&gt; 
let hello = "olá deno"
console.log(hello)
olá deno
undefined
</code></pre>

<h2>Segundo teste, usando um arquivo</h2>

<pre><code>deno run hello.ts # Sim, typescript é builtin
Compile file:///hello.ts
Olá deno
</code></pre>

<h2>Nota final</h2>

<p>Ainda estou conhecendo mais a respeito do uso de runtimes javascript/typescript, fazem parte da stack que usamos no meu trabalho, acho interessante conhecer as possibildades tanto do chamado padrão de mercado, quanto de opções recém chegadas.</p>

<p>Tags: <a href='tag_javascript.html'>javascript</a>, <a href='tag_typescript.html'>typescript</a>, <a href='tag_deno.html'>deno</a></p>





<!-- text end -->
<h3><a class="ablack" href="setup-de-um-linux-para-desenvolvedor-parte-1.html">
Setup de um Linux para DESENVOLVEDOR
</a></h3>
<!-- bashblog_timestamp: #202005141742.47# -->
<div class="subtitle">May 14, 2020 &mdash; 
Fabiano Gomes
</div>
<!-- text begin -->

<p>O ambiente de trabalho, no caso uma máquina com Linux, reflete diretamente na qualidade da execução de tarefas, para desenvolvedores de softwares é fortemente recomendado um ambiente simples, robusto e estável. Pensando nisso, neste vasto universo de distribuições, duas opções bem ortodoxas se destacam. Debian e Slackware, você estará muito bem servido com qualquer uma delas, neste tutorial vamos explorar o Slackware Linux, por que?! Porque é divertido!</p>

<h2>Instalação</h2>

<p>Vou considerar que temos uma instalação de Slackware Linux nova, aqui temos duas possibilidades no que toca instalações:</p>

<ul>
<li>Sem UEFI: Para máquinas com BIOS de antes de 2008(eu acho), no momento de fazer as partições do HD(usando cfdisk) escolher a opção <em>dos</em>;</li>
<li>Com UEFI: Máquinas com BIOS pós 2008, no momento de fazer as partições do HD(usando cfdisk) escolher a opção <em>gpt</em>;</li>
</ul>

<h2>Esquema de partições</h2>

<p>Aqui vamos primar por um esquema simples também:</p>

<ul>
<li>Sem UEFI: 
<ul>
<li>sda1: para /, ext4, 50GB</li>
<li>sda2: para /home, ext4, o que sobrou de espaço em disco após criar sda3</li>
<li>sda3: para swap - a regra para o tamanho do swap é 2XRAM, sendo no máximo 8GB de tamanho(na prática 4GB de swap resolve tua vida).</li>
</ul></li>
<li>Com UEFI: Um pouco mais complexo, este <a href="https://youtu.be/fd0FvvsGaUM">vídeo</a> é uma excelente referência.</li>
</ul>

<p>Embora a instalação seja importante, considero que a pós-instalação é o que realmente faz a diferença, vamos lá!</p>

<h2>Pós-instalação</h2>

<p>A partir deste ponto é onde quero levantar os diferenciais, na minha modesta opinião.</p>

<p>Ao final de uma instalação de Slackware, temos apenas um super usuário e nada mais, vamos começar a preparar nosso ambiente para não precisarmos nos preocupar com eventuais quebras por instalações/atualizações desnecessárias.</p>

<ol>
<li>Conectar na internet: Temos duas opções, a mais tradicional, usando um cabo de rede. Ou caso estejamos usando um notebook, devemos instalar o pacote que está no dvd de instalação do Slackware, na seção extra/wicd chamado wicd-xxx.txz, com ele instalado podemos utilizar o comando <code>wicd-curses</code> no terminal e fazer nossa conexão com a rede que desejamos. Aqui é importante lembrar que o serviço NetworkManager deve estar ativo(<code>chmod +x /etc/rc.d/rc.networkmanager</code>)</li>
<li><p>Após logar como root, vamos escolher um mirror no arquivo /etc/slackpkg/mirrors: Escolha um mirror do Brasil, não vou utilizar o slackware current(não é o objetivo aqui) execute:</p>

<pre><code>slackpkg upgrade
slackpkg upgrade-all
</code></pre></li>
</ol>

<p>Após esse procedimento seu slackware estará atualizadissimo!</p>

<h2>Instalando novos software</h2>

<p>O Slackware tem a má fama de não possuir nenhum gerenciador de pacotes, o que já verificamos não ser verdade no item <em>pós-instalação</em>. Agora vamos adicionar novas ferramentas a nossa caixa de desenvolvimento, o <a href="https://sbopkg.org/">sbopkg</a> é um facilitador para acessarmos o repositório de receitas do <a href="https://slackbuilds.org/">slackbuilds</a>. </p>

<ol>
<li>Baixar o pacote sbopkg-xxx.tgz e instala-lo com o <code>installpkg sbopkg-xxx.tgz</code>;</li>
<li>A partir daqui sempre vamos executar o <code>sbopkg</code> para fazer a instalação de novos pacotes no nosso Slackware.</li>
</ol>

<h2>Próximos passos</h2>

<p>No próximo tutorial vamos configurar um WM(Windown Manager) e adicionar mais ferramentas na nossa caixa de desenvolvimento.</p>

<p>Tags: <a href='tag_wiki.html'>wiki</a>, <a href='tag_linux.html'>linux</a>, <a href='tag_slackware.html'>slackware</a></p>







<!-- text end -->
<h3><a class="ablack" href="minhas-notas-sobre-uso-do-git.html">
Minhas notas sobre uso do git
</a></h3>
<!-- bashblog_timestamp: #202005110818.38# -->
<div class="subtitle">May 11, 2020 &mdash; 
Fabiano Gomes
</div>
<!-- text begin -->

<p>Para <em>trazer</em> os submodulos de um projeto:</p>

<pre><code>git submodule init
</code></pre>

<p>Para <em>atualizar</em> os submodulos:</p>

<pre><code>git submodule update
</code></pre>

<p>Para <em>chavear</em> para um branch especifico dos submodulos:</p>

<pre><code>git submodule foreach 'git checkout develop'
</code></pre>

<p>Para <em>traze</em>' as atualizações de todos os sbmodulos:</p>

<pre><code>git submodule foreach 'git pull'
</code></pre>

<p>Para <em>guardar</em> as alterações em uma pilha <em>anonima</em>:</p>

<pre><code>git stash
</code></pre>

<p>Para aplicar as alterações dessa pilha no branch corrente:</p>

<pre><code>git stash apply
</code></pre>

<p>Para guardar inclusive untracked files:</p>

<pre><code>git stash -u
</code></pre>

<p>Para listar a pilha de <em>stashes</em></p>

<pre><code>git stash list
</code></pre>

<p>Para criar um novo branch a partir de um stash:</p>

<pre><code>git stash branch novo-branch
</code></pre>

<p>Para acessar um stash especifico, acessa através de stash@{n} - por exemplo:</p>

<pre><code>git stash apply stash@{2} # aplica o stash 2 ao branch corrent
git stash drop stash@{2} # Apaga o stash 2 da pilha
</code></pre>

<p>Apagar a pilha de stash:</p>

<pre><code>git stash clear
</code></pre>

<h2>Comparar modificações</h2>

<p>Configurar ferramenta de diff:</p>

<pre><code>git config --global diff.tool meld
</code></pre>

<p>Para comparar dois branches usando a ferramenta gráfica <em>Meld</em>:</p>

<pre><code>git difftool -d ticket-4581..develop
</code></pre>

<p>A lógica é a mesma para fazer um diff entre commits, basta substituir o nome do branch pelo hash do commit(os primeiros 6 digitos são o suficiente).</p>

<h2>Juntar commits</h2>

<p>Para <em>juntar</em> varios commits em um só:</p>

<pre><code>git rebase -i HEAD~&lt;n&gt; # Onde n é a quantidade de commits que desejamos juntar.
</code></pre>

<p>Neste comando iterativo podemos juntar, squash ou remover algum commit que não queremos - para isso basta remover a linha pick que contém o commit(leia as instruções do modo iterativo).</p>

<p>Tags: <a href='tag_wiki.html'>wiki</a></p>








<!-- text end -->
<div id="all_posts"><a href="all_posts.html">View more posts</a> &mdash; <a href="all_tags.html">All tags</a> &mdash; <a href="https://gomes-fdr.github.io/blog/feed.rss">Subscribe</a></div>
</div>
<div id="footer">CC by-nc-nd <a href="">Fabiano Gomes</a> &mdash; <a href="mailto:gomes&#46;fdr&#64;tuta&#46;io">gomes&#46;fdr&#64;tuta&#46;io</a><br/>
Generated with <a href="https://github.com/cfenollosa/bashblog">bashblog</a>, a single bash script to easily create blogs like this one</div>
</div></div>
</body></html>
