<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<link rel="stylesheet" href="main.css" type="text/css" />
<link rel="stylesheet" href="blog.css" type="text/css" />
<link rel="alternate" type="application/rss+xml" title="Subscribe to this page..." href="feed.rss" />
<title>Web notes &mdash; Posts tagged "golang"</title>
</head><body>
<div id="divbodyholder">
<div class="headerholder"><div class="header">
<div id="title">
<h1 class="nomargin"><a class="ablack" href="https://gomes-fdr.github.io/blog/index.html">Web notes</a></h1>
<div id="description">Alguns caracteres perdidos...</div>
</div></div></div>
<div id="divbody"><div class="content">
<h3><a class="ablack" href="ponteiros-em-golang.html">
Ponteiros em golang
</a></h3>
<!-- bashblog_timestamp: #202006201330.49# -->
<div class="subtitle">June 20, 2020 &mdash; 
Fabiano Gomes
</div>
<!-- text begin -->

<p>Em tradução livre, ponteiros são objetos que armazenam endereços de memória <a href="https://en.wikipedia.org/wiki/Pointer_(computer_programming">wikipedia</a>. Um dos temas que podemos tratar quando passamos a utilizar ponteiros, é a maneira como <em>passamos</em> informações de uma função para outra.</p>

<p>Por padrão, quando criamos uma função e definimos algum parâmetro, utilizamos a chamada <em>passagem por referência</em> onde este parâmetro, solicita para o computador que ele reserve um pouco de memória para armazenar o conteúdo de cada parâmetro declarado(sim parâmetros são como as variáveis dos nossos programas).</p>

<pre><code>func dobro(a int) int {
    return a*2
}
</code></pre>

<p>No exemplo acima, uma variável do tipo <code>int</code> foi criada, para receber o valor da nossa função <code>dobro</code>, dentro do nosso programa principal, poderíamos utilizar essa função da seguinte maneira:</p>

<pre><code>func main() {
    x := 10

    fmt.Println("O valor de x  é: ", x)
    fmt.Println("Seu dobro é: ", dobro(x))
}
</code></pre>

<p>A grosso modo, no exemplo acima, criamos duas variáveis de tamanho de um <code>int</code>, como poderíamos fazer a mesma operação sem alocarmos mais uma variável?</p>

<h2>Passagem por referência</h2>

<p>Vamos fazer alguns ajustes na função dobro:</p>

<pre><code>func dobro(a *int) int {
    return *a * 2
}
</code></pre>

<p>Agora a função dobro espera receber um ponteiro, ou se preferir uma referência para uma variável do tipo <code>int</code>, na função principal, a utilização da nossa função que trabalha com referências fica assim:</p>

<pre><code>func main() {
    x := 10

    fmt.Println("O valor de x  é: ", x)
    fmt.Println("Seu dobro é: ", dobro(&amp;x))
}
</code></pre>

<p>Com essa alteração, passamos a reservar apenas uma variável do tipo <code>int</code>, uma vez que nossa função apenas <em>apontou</em> para o valor da variável x e retornou seu valor multiplicado por 2.</p>

<p>Assim como em C e C++ dá pra fazer muitas coisas legais e perigosas com ponteiros, essa foi uma pequena nota para meu eu do futuro pensar a respeito.</p>

<p><em>Importante lembrar que o uso irresponsável de ponteiros pode trazer efeitos indesejados(eu ouvi garbage colector?!)</em></p>

<p>Referências: Série de vídeos do <a href="https://youtu.be/JepHr8egvBI">Claudson Oliveira</a></p>

<p>Tags: <a href='tag_golang.html'>golang</a>, <a href='tag_wiki.html'>wiki</a></p>

<!-- text end -->
<h3><a class="ablack" href="golang-sobre-strings.html">
Golang, sobre strings
</a></h3>
<!-- bashblog_timestamp: #202006142108.25# -->
<div class="subtitle">June 14, 2020 &mdash; 
Fabiano Gomes
</div>
<!-- text begin -->

<p>Estas são algumas anotações que estou fazendo durante o excelente vídeo curso da <a href="https://www.youtube.com/playlist?list=PLCKpcjBB_VlBsxJ9IseNxFllf-UFEXOdg">Ellen Körbes</a> - o conteúdo e alguns trechos de código são de lá.</p>

<h2>O tipo string</h2>

<p>Uma das coisas que achei muito legal em Go, tudo é utf-8! O código fonte e o tipo string é em utf-8. Bom só quem já usou IDEs como o qtcreator ou o eclipse sabe os tipos de problemas inesperados que podemos ter pelo simples fato de o encode do código fonte poder estar em diversos formatos(lá se vão todas as mensagens para o usuário final com caracteres alienígenas).</p>

<h2>Nota histórica</h2>

<p>O mindset para lidar com texto em C, é o seguinte:</p>

<pre><code>"Strings são uma cadeia de char finalizadas com `0`."
</code></pre>

<p>Para lidar com ASCII, tudo bem, mas o mundo é muito grande e trabalhar com todos os símbolos que usamos para nos comunicar, usando apenas a tabela ASCII era um ginástica danada.</p>

<p>Seguindo:</p>

<pre><code>"Um char, em C, são 8 bits."
</code></pre>

<p>Observando estas notas históricas, vejo como foi acertada a escolha de utf-8 para lidar com string em Go.</p>

<h2>Como é em Golang</h2>

<p>Go criou um alias para <code>unit32</code> chamado <code>rune</code>, cada <code>rune</code> representa um caractere de uma string em Go. Isso impacta diretamente em operações de slice(fatiamento).</p>

<pre><code>package main

import (
    "fmt"
)

func main() {
    a := "e"
    b := "é"
    c := "香"
    fmt.Printf("%v, %v, %v\n", a, b, c)

    d := []byte(a)
    e := []byte(b)
    f := []byte(c)

    fmt.Printf("%v, %v, %v", d, e, f)
}

e, é, 香
[101], [195 169], [233 166 153]
</code></pre>

<p>Observe:</p>

<pre><code>// caractere | decimal | hexa | binário  | no. byte(s)
           e |     101 |   65 |  1100101 |           1
           é |   50089 |   C3 | 11000011 |
             |         |   A9 | 10101001 |           2
          香 | 15312537|   E9 | 11101001 |
                           A6 | 10100110 |
                           99 | 10011001 |           3
</code></pre>

<p>O primeiro caractere <code>e</code> está na tabela ASCII, utf-8 é um superset desta tabela, logo pode representar seus valores com total compatibilidade. Como tal, usa um byte para representa-lo.</p>

<p>O segundo caractere não pode ser representado usando ASCII, logo cai nos casos em que utf-8 passa a nos ajudar de fato, para representar esse caractere, são necesários 2 bytes.</p>

<p>O terceiro caractere também não pode ser representado usando ASCII e está em um range superior da tabela utf-8 e necessita de 3 bytes para representa-lo.</p>

<p>Em resumo, a tabela ASCII pode representar 2<sup>8</sup> valores diferentes(256), já a tabela de utf-8 pode representar 2<sup>32</sup> valores diferentes(4294967296) - sendo que ASCII está contido nesta tabela, acho que até o alfabeto Klingon está lá.</p>

<p>Este exemplo simples mostra muito bem como fica fácil de lidar com strings em Golang, gostaria de deixar o link para uma excelente explicação complementar de como funciona a lógica por trás da codificação utf-8, ele também é um material criado pela <a href="https://medium.com/deffectivego/wtf-utf-8-85bc66a6279">Ellen Körbes</a>.</p>

<p>Recomendo fortemente.</p>

<p>Tags: <a href='tag_golang.html'>golang</a>, <a href='tag_wiki.html'>wiki</a></p>

<!-- text end -->
</div>
<div id="footer">CC by-nc-nd <a href="">Fabiano Gomes</a> &mdash; <a href="mailto:gomes&#46;fdr&#64;gmail&#46;com">gomes&#46;fdr&#64;gmail&#46;com</a><br/>
Generated with <a href="https://github.com/cfenollosa/bashblog">bashblog</a>, a single bash script to easily create blogs like this one</div>
</div></div>
</body></html>
